## 콜백 함수

콜백 함수는 다른 코드의 인자로 넘겨주는 함수다. 그리고 콜백 함수를 넘겨받은 코드는 해당 함수를 `실행할 시점을 직접 정하게 된다.`

---

## 일급 함수

> 컴퓨터 프로그래밍 언어 디자인에서, 일급 객체(영어: first-class object)란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 보통 함수에 인자로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다.
>
> - 위키 백과

위의 특징을 만족하는 객체를 일급 객체라고한다. 자바스크립트에서는 함수가 일급 객체로 동작한다. 즉, 함수를 하나의 값으로 평가할 수 있다는 것이다. 그렇기 때문에 변수에 할당하거나, 함수의 인자로 넘겨주거나, 함수의 반환값으로 함수를 반환할 수 있게 되는 것이다.

함수가 일급 객체가 된다는 것이 중요한 의미인 이유는 고차함수에서 나타나게 된다. 함수형 프로그래밍을 하면서 고차 함수는 굉장히 강력한 기능을 한다.

```javascript
const exec = (f, a) => f(a);

exec(console.log, 1); // 1
exec((a) => a + 1, 1); // 2
```

위의 코드의 경우 `exec`함수가 함수를 인자로 받아 `a`라는 매개 변수를 그 함수의 인자로 넘겨주는 역할을 한다.

## 고차함수

고차함수는 함수를 인자로 받거나, 함수를 리턴하는 함수를 말한다. 여기서 함수를 인자로 받는 경우 그 인자로 받은 함수를 콜백함수(`callback`)라고 한다.

함수를 인자로 받을 수 있다는 것은 함수 내부에서 콜백 함수의 실행 여부를 결정하거나, 원하는 위치에서 실행하는 등 함수 실행에 대한 결정이 자유로워 진다는 것이다.

또한 고차함수를 이용하여 조합성과 추상화를 통해 코드를 좀 더 작은 기능의 단위로 나눌 수 있고, 여러 함수를 조합해 하나의 기능을 만들 수도 있다.

다시 위의 코드를 보자.

```javascript
const exec = (f, a) => f(a);

exec(console.log, 1); // 1
exec((a) => a + 1, 1); // 2
```

이 코드에서 `exec`코드는 단순히 `f`에 `a`를 인자로 넣어 실행하는 고차함수다. 여기서 중요한 것은 `exec`함수는 실행시킬 `f`함수가 어떤 함수인지 상관하지 않고 `a`를 인자로 넘겨 실행한다는 것이다. 이런 방법이 바로 추상화다. 자신이 실행할 함수의 기능은 인자로 넘겨받는 `f`라는 함수에 완전히 위임하고 단순히 인자로 받은 `f`에 `a`를 인자로 넣어 실행하는 기능을 하는 것이다.

그렇기 때문에 위의 코드에서 `console.log`와 `(a) => a + 1`의 두 함수가 모두 인자로 사용될 수 있는 것이다. `exec`는 받는 함수가 어떤 함수인지 신경쓰지 않기 때문이다.

```javascript
const adder = (a) => (b) => a + b;

console.log(adder(1)(2)); // 3
```

위의 코드는 함수를 리턴하는 고차함수다. 그렇기 때문에 `adder(1)(2)`와 같은 형태가 나올 수 있다. 하나하나 보게 되면, 우선 `adder`에 인자로 1을 넘겨준다. 그러면 함수 `(b) => 1 + b`가 반환되게 된다. 물론 1은 편의상 내가 넣은 것이다. 위의 코드는 클로저를 만드는 함수를 리턴한 것이기 때문이다. 이후 반환된 함수에 인자로 2를 넣어 실행한 것이 위와 같은 형태다.

이런 함수를 커링 함수라고 한다. 커링 함수가 유용한 이유는 하나의 기능을 하는 함수를 미리 만들 수 있다는 것이다.

```javascript
const addOne = adder(1);

console.log(addOne(5)); // 6
```

위와 같이 `adder`함수를 이용해서 입력값에 1을 더해주는 함수인 `addOne`을 만들었다. 이런 식으로 커링을 이용하면 하나의 기능을 추출해서 이후에 받아야 할 인자를 나중으로 미룰 수 있게 된다.

## 콜백

자바스크립트에서는 비동기를 지원하는 함수들이 있다. 대표적인 경우가 `setTimeout`이다.
`setTimeout`은 비동기 처리를 콜백을 이용해서 해결한다. 일정 시간이 지나면 콜백함수의 결과를 확인할 수 있는 것이다. 단, 이 함수 역시 비동기로 처리되기 때문에 콜스택이 비었을 때 실행된다는 것을 알아두자.

```javascript
setTimeout(() => console.log("time"), 0); //0초 뒤에 콜백함수를 실행한다.

console.log("sync");

// 'sync'
// 'time'
```

위 함수를 보면 0초 뒤에 콜백을 실행하게 코드를 작성했지만, 결과는 콜백함수가 즉시 실행되는 것이 아니라 아래 `console.log`가 실행되고 난 후 실행된다. 이미 말했듯이 콜스택에는 `console.log('sync')`가 먼저 올라가서 실행되고 그 후에 콜스택이 비어있게 되므로 콜백함수가 콜스택으로 올라가게 된다.

실제로는 어떻게 동작할까?
`setTimeout`을 코드 실행 도중 만나게 되면 우선 콜스택에 올라간다. 이후 바로 스택에서 나오면서 백그라운드에 타이머와 콜백을 넘겨주게 된다. 백그라운드에서 일정 시간 뒤에 콜백 함수를 테스크 큐에 넘겨주게 되고, 콜 스택에 모든 함수가 빠져나가게 되면, 테스크 큐에 있던 콜백함수가 콜 스택으로 들어가게 된다.

이런 방식으로 비동기 처리가 이루어진다. 그렇기 때문에 코드 흐름에 맞게 비동기 코드를 처리하려면 다른 방법이 필요하다. 대표적인 방법은 콜백함수를 사용하는 방법이다.

```javascript
const data = [1, 2, 3];
const pushData = (el, callback) => {
  data.push(el);
  callback();
};
setTimeout(() => pushData(4, () => console.log(data)), 0);
console.log(data);

//[1,2,3]
// undefined => 첫 콘솔로그의 return값이다.
//[1,2,3,4]
```

위 코드를 실행하면 결과가 위와 같이 나온다. 코드를 확인해보자. 우리가 원하는 것은 일정 시간이 지나고 `data`에 새로운 요소를 집어 넣은 후, 변한 데이터를 확인하는 것이다.
하지만, `setTimeout`이후에 `console.log`를 하게 되면 변한 데이터가 아니라 첫 데이터의 모습이 콘솔에 출력된다. 그 이유는 위에서 말했듯 동기처리가 먼저 콜스택에서 실행되기 때문에 비동기에서 처리한 `push`가 실행되지 않은 상태이기 때문이다.

그럼 어떻게 확인해야 할까? 바로 비동기 처리에서 확인하는 방법밖에 없다. `pushData`를 보게되면 `el`를 `data`에 넣고 바로 콜백함수를 실행한다. 이렇게 되면, 데이터에 새로운 요소를 추가한 이후 콜백 함수가 실행되기 때문에 비동기처리 이후 추가적인 행동을 할 수 있는 것이다.

여기선 그 행동을 `console.log`라고 생각하면 된다. 그래서 `setTimeout`을 보면 콜백함수가 내부에서 `console.log(data)`를 하고 있는 것을 확인할 수 있다.

위 코드에서는 콜백함수를 이용해 데이터를 추가하는 것을 연속적으로 할 수 있다.

```javascript
const data = [1, 2, 3];
const pushData = (el, callback) => {
  data.push(el);
  callback();
};
setTimeout(
  () =>
    pushData(4, () => pushData(5, () => pushData(6, () => console.log(data)))),
  0
);
console.log(data);

//[1,2,3]
// undefined => 첫 콘솔로그의 return값이다.
//[1,2,3,4,5,6]
```

위와 같은 방식으로 콜백함수를 계속 넣어주면서 비동기 처리를 순차적으로 진행할 수 있다.
하지만, 만약 이런 처리가 많아지게 되면 가독성에 좋지 않게 된다. 또한 비동기 처리가 콜백함수 내로 한정될 수 밖에 없다. 이를 해결하기 위해 프로미스가 등장했다.

## 프로미스

프로미스는 비동기 상황을 일급 값으로 다룰 수 있게 만들었다는 것이 중요하다. 단순히 콜백 지옥에서 벗어나기 위해서 쓰는 것이 아니라는 것이다.

```javascript
const add10 = (a) => new Promise((resolve) => resolve(a + 10));

add10(5).then((res) => console.log(res));
// 15
```

위와 같은 방식으로 프로미스를 사용하게 되면 비동기적으로 10을 더해주는 상황을 add10이라는 변수에 담을 수 있고, 내가 원하는 시점에 인자를 주면서 비동기 상황을 수행할 수 있게 된다. 이런 관점에서 프로미스와 콜백의 차이는 정말 크다는 것을 알 수 있다.

이렇게 된다면, 비동기 상황을 함수의 인자로 취급할 수 있기 때문에 여러 비동기 상황을 조합하는 것도 가능하게 된다.

프로미스는 두 가지 콜백 함수를 인자로 전달한다. 바로 `resovle`와 `reject`다 `resolve`는 비동기 상황이 정상적으로 처리가 된 경우 호출해야 하며, `then`메소드를 통해 `resolve`함수에 전달한 인자를 받을 수 있다. `reject`는 정상적으로 처리되지 않은 경우 호출해야 하며, `catch`메소드로 받을 수 있다.

### then

프로미스에는 `then`메소드를 붙일 수 있다. 프로미스에서 `resolve`를 통해 보내준 값을 `then`에서 받아 처리를 할 수 있게 되는 것이다. 콜백과 비슷한 것이다.

### catch

프로미스에서 `reject`한 경우 앞에 모든 `then`체이닝을 무시하고 `catch`메소드로 가게 된다. `then`과 마찬가지로 `reject`가 전달한 값을 받아 처리할 수 있다.

## async await

프로미스 상황에서도 `then`이 계속 체이닝되면 보기 어려운 경우가 생긴다. `await`을 사용하게 되면 그것을 조금 나은 코드로 변경할 수 있다.
