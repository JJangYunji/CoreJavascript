# 1장 데이터 타입

## 기본형과 참조형을 구분하는 방법

기본형과 참조형을 구분하기 위해서는 메모리 주소에 대한 개념이 필요하다. 기본적으로 모든 프로그래밍 언어는 컴퓨터의 메모리를 이용해서 데이터를 저장하고, 데이터를 사용해서 어떤 작업을 수행하게 된다.

여기서 메모리는 프로세스가 실제로 실행될 때 할당되는 공간이다. 각 프로세스마다 정해진 메모리 크기가 있고, 그 메모리 내에서 데이터나 함수들을 저장하게 되는 것이다. 물론, 메모리는 휘발성이기 때문에 영구적으로 저장되는 것은 아니다.

본론으로 돌아가 기본형과 참조형을 구분하기 위해서 메모리 주소를 알아야 하는데, 우리가 변수를 선언하고 값을 할당하게 되면 해당 값은 특정 메모리 주소에 존재하게 된다.

여기서 기본형인 데이터의 경우 (예를 들면, `number type`) 변수가 가리키는 것은 실제 값이 존재하는 메모리 주소를 의미한다. 참조형(`Array, Object...`)을 담은 변수 역시 메모리 주소를 가리키지만, 그 메모리 주소에는 실제 배열이나 객체가 들어있는 것이 아니라, 배열과 객체가 존재하는 어떤 영역의 또 다른 주소를 가리키는 것이다. 즉, 하나의 주소를 더 거쳐서 가리킨다고 생각하면 된다.

이 둘의 차이가 어떻게 보여지냐면, 값을 복사하여 비교할 때 쉽게 볼 수 있다.

```js
test("test가 동작하는 지 확인합니다.", () => {
  expect(1 + 2).toBe(3); // 3
});

test("기본형의 변수는 새로운 주소에 같은 값을 복사합니다.", () => {
  let a = 1;
  let b = a;

  expect(a === b).toBeTruthy(); // true
  true;
});

test("기본형은 복사한 변수의 값이 바뀌면 원본 값과 서로 다르게 됩니다.", () => {
  let a = 1;
  let b = a;

  b = 2;
  expect(a === b).toBeFalsy(); // false
});

test("참조형은 생성된 데이터가 존재하는 주소를 공유합니다.", () => {
  const arr = [1, 2, 3];
  const arr2 = arr;

  expect(arr === arr2).toBeTruthy(); // true
});

test("참조형은 주소를 공유하기 때문에 공유하는 다른 변수가 원본 값을 바꾸면 모든 변수의 값도 같이 바뀌는 것처럼 보입니다.", () => {
  const arr = [1, 2, 3];
  const arr2 = arr;

  arr2[1] = 0;

  expect(arr2).toEqual([1, 0, 3]); // [1,0,3]
  expect(arr).toEqual([1, 0, 3]); // [1,0,3]
  expect(arr === arr2).toBeTruthy(); // true
});
```

위 테스트 코드를 보면, 기본형과 참조형 모두 하나의 값을 다른 변수에 `복사`했을 때, 서로 같은 지 비교하면 `true`를 반환한다. 하지만, 기본형의 경우 복사한 변수의 값을 `2`로 바꾸고 다시 한 번 같은지 비교를 하면 `false`를 반환한다.

참조형은 어떨까? 참조형도 기본형과 마찬가지로 값을 `복사`하고, 복사한 변수에서 값의 일부를 바꾸었을 때, 같은지 비교하면 `true`를 반환한다. 참조형의 경우 메모리 상에서 단 하나의 값을 만들게 되고, 해당 값을 `참조`하는 모든 변수는 모두 그 값이 존재하는 주소를 가지고 있게 된다. 그 중 하나의 변수가 그 값에 변화를 주게 되면, 그 값을 바라보던 다른 변수들에게도 영향이 가게 된다. 보통 이럴 때 원본값에 변화를 준다고 한다. 원본값이 변하게 되면 코드의 흐름 파악이 힘들어지고, 예상치 못한 결과를 얻게 될 수 있는 위험이 있다.

## 불변값

기본형과 참조형을 얘기를 하면 꼭 나오는 말이 있다. 바로 `불변값`이다. 쉽게 생각하면 기본형은 불변하고, 참조형은 가변한다고 생가할 수 있다. 어느 정도 맞지만, 참조형이 `변한다.`라고 할 수 있을 때는 데이터의 내부 값을 바꿀 때를 의미한다. 데이터 자체를 바꾸는 것은 참조형 역시 변한다고 볼 수 있다.

여기서 데이터 자체를 바꾼다는 의미는 기존 값을 새로운 참조형 데이터로 바꾼다는 것이다. 이렇게 되면, 기존 데이터가 새로운 데이터로 갈아 끼워지는 것이 아니라, 새로운 데이터가 새로운 주소에 할당되고, 변수는 그 주소를 보게 된다. 즉, 변수에 할당된 데이터의 주소가 `바뀌게 된다.` 이런 경우를 우리는 `값이 변한다`라고 할 수 있다.

기본형과 참조형이 각각 불변하고 가변한다는 것은 위의 테스트를 통해서도 설명이 가능하다. 그렇다면, 참조형이 불변하는 경우 즉, 데이터를 바꾸는 경우는 어떻게 되는 지 확인해보자.

```js
test("참조형의 데이터는 내부 값을 변경할 때 가변적입니다.", () => {
  const arr = [1, 2, 3];
  const arr2 = arr;

  expect(arr === arr2).toBeTruthy();
  arr2[0] = 2;
  arr2[1] = 3;
  arr2[2] = 4;

  expect(arr2).toEqual([2, 3, 4]);
  expect(arr).toEqual([2, 3, 4]);
  expect(arr === arr2).toBeTruthy();
});

test("참조형의 데이터를 다른 참조형으로 바꾸면, 새로운 주소가 할당되어 공유 관계가 끊어집니다.", () => {
  const arr = [1, 2, 3];
  let arr2 = arr;

  expect(arr === arr2).toBeTruthy();

  arr2 = [2, 3, 4];
  expect(arr2).toEqual([2, 3, 4]);
  expect(arr).toEqual([1, 2, 3]);
  expect(arr === arr2).toBeFalsy();
});
```

첫번째 테스트를 보면, `arr2`가 결국 `[2,3,4]`라는 값을 갖게 된다. 하지만, 내부의 값을 직접 변경하였으므로, 원본 값이 바뀌어 `arr`도 `[2,3,4]`가 된다.

두번째 테스트의 경우는 다르다. `arr2`를 `[2,3,4]`로 직접 새로운 참조 데이터를 할당했을 때, `arr`과 `arr2`는 같은 주소를 더이상 바라보지 않게 되어 서로 다른 값을 갖게 된다.

## 얕은 복사와 깊은 복사

위 내용을 살펴보았을 때, 참조형은 도대체 어떻게 복사를 하는 것이 좋을까? 기본적으로 버그를 발생시키지 않으려면 원본값의 변경은 하지 말아야 한다.

얕은 복사는 참조형 데이터를 공유하는 변수가 생기는 것을 의미한다. 깊은 복사는 같은 형태의 참조형 데이터이더라도 서로 다른 주소를 갖게 만드는 것을 의미한다.

최대한 얕은 복사를 피하고, 깊은 복사를 하는 것이 좋겠지만, 깊은 복사에 필요한 비용이 생각보다 클 수 있다는 것을 명심해야 한다. 우리가 사용하는 데이터의 형태가 중첩적으로 참조형 데이터를 가지고 있다면, 그 깊이가 얼마일지 모르기 때문에 계속 재귀적으로 참조 관계를 끊어야 하기 때문이다.

결과적으로 깊은 복사는 새로운 같은 형태의 참조형 데이터를 만드는 것과 같은 동작을 하는 것이다.
