## 1주차 데이터 타입

자바스크립트가 데이터를 처리하는 과정을 알아보자!

목차

- 데이터 타입의 종류
- 데이터 타입에 관한 배경지식
- 변수선언과 데이터 할당
- 기본형 데이터와 참조형 데이터
- 불변객체
- undefined와 null
- 정리

---

### 데이터 타입의 종류

자바스크립트의 데이터 타입은 크게 두가지로 나뉜다. Primitive type(기본형) 과 Reference type(참조형) 으로 말이다.
이 둘의 기준은 뭘까?
기본형은 값이 담긴 주솟값을 바로 복제하고, 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.

### 데이터 타입의 종류

컴퓨터는 모든 데이터를 0과1로 저장한다. 이를 bit(이하 비트)라고 하는데, 비트는 고유한 식별자를 가진다. 컴퓨터의 메모리에서 이 비트 몇개를 묶어 byte라는 단위를 만들었다. 바이트도 동일하게 고유한 식별자를 지녀 이 메모리 주솟값을 통해 값을 구분하고 연결할 수 있다.

자바스크립트는 숫자 변수 하나를 8byte로 할당해 메모리공간을 확보한다.(표현할 수 있는 숫자범위)

변수와 식별자는 어떻게 다를까?

변수는 컴퓨터용어로 쓸 때 '변할 수 있는 무언가'로 말할 수 있다. 여기서 '무언가'는 데이터(숫자,문자열,객체, 배열 등)를 말한다.
식별자는 변수명(어떤 데이터를 식별하는데 사용하는 이름)이다.

### 변수선언과 데이터 할당

번수를 선언하는 동작원리를 알아보자

```
var a
```

우리는 변할 수 있는 데이터를 만들었고, 이의 식별자는 a로 하기로 했다!

이렇게 선언할 때, 컴퓨터는 메모리에서 빈 공간 하나를 확보한다.(8byte만큼) 이 공간의 식별자를 'a' 라고 선언한 것이다.
나주에 사용자가 a에 접근하고자 할 때, 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 그 공간에 담긴 데이터를 변환한다.

```
a = 'abc';
```

이제 데이터를 할당해보자.
우리는 a로 선언된 메모리 공간에 'abc'를 바로 저장한다고 생각하지만 그렇지 않다. 컴퓨터는 변수영역과 데이터 영역을 구분하고 있다.

변수영역에는 식별자 a와, 값이 담긴 데이터 영역의 주소를 저장한다.
데이터 영역에는 문자열 'abc'를 저장한다.

이렇게 변수영역과 데이터 영역을 구분하는 이유가 있을까?
: 데이터 변환을 자유롭게 하고 & 메모리의 효율적인 관리를 위해서이다.

<!-- 숫자 데이터는 위에서 언급했듯이 8 byte만 있으면 되지만, 문자열은 길이에 따라 메모리가 가변적이다. 따라서 변수영역과 데이터 영역을 구분하지 않으면, 데이터 변환 시 해당 데이터 공간 뒤의 변수들을 하나씩 뒤로 옮겨야 하기 때문에 연산이 많아진다.(변수영역과 데이터 영역을 구분하지 않는데, 식별자를 다시 연결할 필요는 없지 않나?) -->

만약에 데이터를 재할당 할때는 어떻게 되는가?<br/>
컴퓨터는 'abc'가 저장된 공간에 'abcdef'를 할당하지 않는다. 대신 문자열을 새로 만들어 별도의 공간에 저장하고, 이 주소를 변수공간에 연결한다. 이는 제거할 때도 마찬가지.
기존 문자열에 어떤 변환을 가하든 상관없이 무조건 새로 만든다.

변수영역에 만들어진 값은 재사용 할 수 있을까?<br/>
정답부터 말하자면 가능하다. 주소공간이 2byte인 공간에 a1, a2, ..., a500 의 변수 500개를 생성해서 이곳에 숫자 5를 할당한다면 (500*2+8)=1008byte만 사용하면 된다. 하지만 값을 재사용 하지 못한다면 (500*2+500*8)=5000byte, 변수영역과 데이터 영역을 구분하지 않는다고 해도 (500*8)=4000byte 가 필요하다.

### 기본형 데이터와 참조형 데이터

변수와 상수의 차이는 변경가능성이다.
하지만 상수 !== 불변값 이다.
변수와 상수를 구분짓는 대상은 변수영역의 메모리 이다. 변수공간에 다른 데이터를 재할당 할 수 있는지에 대한 여부가 관건이다. 반면 불변성 여부를 구분하는 대상은 데이터영역의 메모리이다.

불변값<br/>
기본형 데이터는 모두 불변값이다. 기본형 데이터에는 숫자, boolean, null, undefined, symbol 등이 있다. 이 데이터들은 변수영역의 데이터의 값은 변하더라도, 데이터영역의 데이터는 변하지 않는다. 이것을 불변성이라고 말한다.

가변값<br/>
참조형 데이터는 가변값일 수도 아닐수도 있다. 기본적인 성질은 가변값인 경우가 많기 때문에, 참조형 데이터를 변수에 할당하는 과정에 대해 알아보자.

참조형 데이터는 기본형과 다르게 데이터 영역에 값을 그대로 저장하지 않고 주소값을 저장한다. 따라서 변수영역, 데이터영역, 객체의 변수(프로퍼티)영역 이 세가지의 영역에 나눠 정보가 저장된다.
데이터 영역의 데이터를 @7103변수 영역에 저장하기로 했다면, @7103의 주소부터 객체의 프로퍼티에 대한 식별자와, 그 값의 주소를 저장한다.
프로퍼티의 값은 기본형 데이터와 동일하게 데이터영역에 저장된다.
이 부분때문에 참조형은 가변값이다(불변하지 않다)라고 말한다.

참조형 데이터 재할당<br/>
참조형 데이터의 프로퍼티 값을 바꾸면, obj1이바라보는 주소가 바뀌지 않고, 프로퍼티 영역의 주소만 바뀐다. 즉 '새로운 객체'가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀌는 것이다.

참조형 데이터의 프로퍼티 값이 참조형 데이터(ex.배열)인 경우도 동일하다. 프로퍼티 영역에 배열의 주소값을 넣고, 배열의 변수영역을 따로 잡아 저장한다.

변수복사 비교<br/>
기본형 데이터와 참조형 데이터의 차이는 변수를 복사할 때 나타난다. 이전에 언급했던 대로, 기본형 데이터는 변수를 복사하면 데이터영역의 같은 주소를 바라본다. 참조형 데이터도 같은 주소를 바라보는것은 동일하다.

```
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;
```

위처럼 하면, 변수영역에서 obj1과 obj2가 가리키는 주소값이 같게 된다.
이 때, 객체의 프로퍼티를 변경한다면

```
b = 15;
obj1.c = 20;
```
기본형 데이터 b는 a와 다른 주소에 값이 할당되므로 a !==b 가 되지만, obj1===obj2이기 때문에 obj2.c의 값도 동일하게 변경된다.

기존 js지식에서는 '기본형은 값을 복사하고 참조형은 주소값을 복사한다'라고 설명한다. 하지만 이는 잘못된 설명으로, 어떤 데이터 타입이든 변수에 할당하기 위해서는 주소값을 복사한다.
기본형은 주소값을 복사하는 과정이 한번 이뤄지고, 참조형은 한단계가 추가되는 차이일 뿐이다. 

추가적으로 obj1.c = 20; 대신 객체 자체를 변경하면
```
...
var obj2 = obj1;
obj2 = { c: 20, d: 'ddd'}; 
```
obj2에 새로운 객체를 할당한 것이 된다. 따라서 새로운 공간에 새 객체가 저장된다.
<!-- 얕은복사 깊은복사 -->


### 불변객체
앞서 객체가 가변적인 경우를 다뤄보았는데, 객체불변성을 확보해야 할 필요가 있을 경우가 있다. 이럴때는 위처럼 객체 데이터 자체를 할당하면 된다. 그러면 내부 프로퍼티를 변경할 필요가 있을 때마다 새로운 객체를 만들어 재할달하기로 규칙을 정한다면, 객체불변성을 확보할 수 있다.

(ES6에서는 spread operator를 통해 작성하면 한방이지만, 이 책에서는 ES5만 다루고 있기 때문에 다양한 방법 소개.)

여러 함수를 작성해서 불변객체를 만들 수 있지만, immutable.js, baobab.js등 라이브러리를 사용해서 시스템적으로 불변객체를 보장할 수 있다.



### undefined와 null
자바스크립트에 '없음'을 나타내는 두가지 값으로, 미세한 의미의 차이와 사용하는 다른 목적을 확인하다.

undefined<br/>
undefined는 자바스크립트 엔진이 값이 존재하지 않을 때 자동 부여한다. 물론 사용자가 undefined로 명시적으로 지정할 수 있다.

JS엔진은 당연히 어떤값을 지정할것이라고 예상했음에도, 그렇게 하지 않았을 때, undefined를 반환한다.
그 경우는 다음 세가지이다.

- 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때 
- 객체 내부의 존재하지 않는 프로퍼티에 접근
- return 문이 없거나 호출되지 않은 함수의 실행결과 

<!-- 배열 인스턴스의 비어있는 요소와 undefined를 할당한 요소 -->

개발자가 undefined를 직접 할당하지 않으면, 통제 범위를 벗어나는 JS엔진의 undefined만 확인할 수 있다.
따라서 이런 경우에 undefined대신 null이란 값을 할당한다.

null의 한가지 주의할점은
```
console.log(typeof null); //object
```
이다.

이는 자바스크립트 자체 버그로 어떤값이 null인지 판단하기 위해서는 === 연산자를 사용하면 된다.